{"meta":{"title":"依然.刘","subtitle":"桃花流水依然在，不见当时劝酒人。  前端路上，纵情向前！ ","description":"前端 js ts electron react","author":"刘百灵","url":"https://liubailing.github.io"},"pages":[{"title":"数组去重","date":"2020-03-15T06:48:10.000Z","updated":"2020-03-24T23:54:43.789Z","comments":true,"path":"数组去重/index.html","permalink":"https://liubailing.github.io/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/","excerpt":"","text":"ES6 Setes6 新数据结构，简单明了一句话。1234// 数组let arr = [1,2,2,3,3,3,4,5];// 新数组let newArr = new Set(arr);单循环 借助,有唯一值的数据结构 如： es6 Map， object{key:value}新数据结构，利用其key值唯一的特性。12345678910111213141516171819202122232425262728// 数组let arr = [1, 2, 2, 3, 3, 3, 4, 5]// 新数组let temp = new Map();for (let v of arr) &#123; if (!temp.has(v)) &#123; temp.set(v, v); &#125;&#125;let newArr = Array.from(temp.keys());console.log(newArr)// 新数组let temp1 = &#123;&#125;;for (let v of arr) &#123; if (!temp1[v]) &#123; temp1[v] = v; &#125;&#125;let newArr1 = Array.from(Object.keys(temp1)); // stringconsole.log(newArr1)单循环、数组本身的 inculdes借助数组自带判断本身是否包含的元素1234567891011121314// 数组let arr = [1, 2, 2, 3, 3, 3, 4, 5]console.log(arr.lastIndexOf(2))// 新数组let newArr = []// 循环for (let v of arr) &#123; // newArr.index(x) // newArr.findIndex(x=&gt; x == v) // newArr.lastIndexOf(x=&gt; x == v) if (!newArr.includes(i)) &#123; newArr.push(i); &#125;&#125;双循环 splice去重自身去重，不借助新数组12345678910111213// 数组let arr = [1, 2, 2, 3, 3, 3, 4, 5]for (let i = 0; i &lt; arr.length; i++) &#123; for (let j = i + 1; j &lt; arr.length; j++) &#123; if (arr[i] == arr[j]) &#123; arr.splice(j, 1) j-- &#125; &#125;&#125;console.log(arr)双循环 朴实无华直接上代码123456789101112131415161718192021// 数组let arr = [1, 2, 2, 3, 3, 3, 4, 5]// 新数组let temp = [];for (const v of arr) &#123; let isIn = false for (const v1 of temp) &#123; if (v == v1) &#123; isIn = true; break &#125; &#125; if (!isIn) &#123; temp.push(v) &#125;&#125;console.log(temp)"},{"title":"关于我","date":"2020-03-07T09:57:47.000Z","updated":"2020-03-08T04:25:37.109Z","comments":true,"path":"about/index.html","permalink":"https://liubailing.github.io/about/","excerpt":"","text":"自我介绍毕业于江西农业大学，统招本科软件工程专业堆码好多年，做过C#、php、前端，也接触了一点C++、python。过往不念，现在是专职前端、前端、前端,偶尔客串打杂和一个老板创业多年，期间曾就职过宝驾租车、华为、亿阳信通过往不念，现在就职于八爪鱼高级前端做过好多项目,P2P租车前三宝驾租车,团购网站前十聚齐网过往不念，现在从0-1做八爪鱼采集器纵情向前"}],"posts":[{"title":"path.join 和path.resolve的区别","slug":"mac/path.join 和path.resolve的区别","date":"2020-04-11T16:00:00.000Z","updated":"2020-05-22T00:43:15.195Z","comments":true,"path":"20200412/mac/path.join 和path.resolve的区别/","link":"","permalink":"https://liubailing.github.io/20200412/mac/path.join%20%E5%92%8Cpath.resolve%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"所谓坑其实也算不上坑，只能说没理解好path.join的用法，path.join()有两个要注意的地方台特定的分隔符[Unix系统是/，Windows系统是\\ ]‘..’作为上一级路径 应该放在拼接的后面join是把各个path片段连接在一起，1234567891011121314151617181920212223__dirname// __dirname返回当前文件所在的绝对路径const path = require('path');const path1 = path.join(__dirname, '/foo');const path2 = path.join(__dirname, './foo/bar');const path3 = path.join('/foo', 'bar', '/baz/apple', 'aaa', '..');const path4 = path.join('foo', 'bar', 'baz');const path5 = path.join('foo', 'bar', '..', '..')console.log(path1);console.log(path2);console.log(path3);console.log(path4);console.log(path5);// 输出结果/Users/Admin/work/test/foo/Users/Admin/work/test/foo/bar/foo/bar/baz/applefoo/bar/baz.path.resolve()resolve操作相当于进行了一系列的cd操作,把‘／’当成根目录12345678910111213141516171819202122232425262728const path = require('path');const path1 = path.resolve('/a/b', '/c/d');// 结果： /c/dconst path2 = path.resolve('/a/b', 'c/d');// 输出： /a/b/c/dconst path3 = path.resolve('/a/b', '../c/d');// 输出： /a/c/dconst path4 = path.resolve('a', 'b');// 输出： /Users/Admin/work/test/a/b``` ## 扯远一点### process.cwd()和__dirname的区别&gt;1. process.cwd()返回当前工作目录。如：调用node命令执行脚本时的目录。&gt;2. __dirname返回源代码所在的目录。``` javascript// eg：对于d:\\dir\\index.jsconsole.log(`cwd: $&#123;process.cwd()&#125;`);console.log(`dirname: $&#123;__dirname&#125;`);命令process.cwd()__dirnamenode index.jsd:\\dir单元格d:\\dir snode dir\\index.jsd:d:\\dir","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://liubailing.github.io/tags/node/"}],"keywords":[]},{"title":"launchpad部分图标不显示","slug":"mac/launchpad部分图标不显示如何解决","date":"2020-03-11T16:00:00.000Z","updated":"2020-03-12T11:28:47.425Z","comments":true,"path":"20200312/mac/launchpad部分图标不显示如何解决/","link":"","permalink":"https://liubailing.github.io/20200312/mac/launchpad%E9%83%A8%E5%88%86%E5%9B%BE%E6%A0%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/","excerpt":"","text":"网上搜了一把，应该是macOS图片缓存出了问题，可能是刚才一直在测试Electron打包，频繁安装卸载导致的问题清理重建 macOS 图标缓存打开终端输入如下命令sudo find /private/var/folders/ \\( -name com.apple.dock.iconcache -or -name com.apple.iconservices \\) -exec rm -rfv {} \\; sudo rm -rf /Library/Caches/com.apple.iconservices.store;killall Dockkillall Finder```即完成了图标清理，Kill 掉 Dock 和 Finder 后，程序会自动重建缓存文件。","categories":[],"tags":[{"name":"mac","slug":"mac","permalink":"https://liubailing.github.io/tags/mac/"}],"keywords":[]},{"title":"奇葩杂症","slug":"奇葩杂症","date":"2020-03-05T05:08:43.000Z","updated":"2020-05-21T02:11:45.307Z","comments":true,"path":"20200305/奇葩杂症/","link":"","permalink":"https://liubailing.github.io/20200305/%E5%A5%87%E8%91%A9%E6%9D%82%E7%97%87/","excerpt":"","text":"fs读取json文件 格式问题nodejs 读取json文件然后用JSON.parse转回Json需要注意的注意的问题是：文件格式需要是utf-8electron （5.0.4）2020/04/01 - 2020/04/30electron-build 打包配置问题，因为要动态打包，所以把原本在package.json文件里面build属性移除外面，引起依赖包重新编译时候会重新rebuild依赖包，导致打包时候的node_modules可能与之前的不同（我们正好碰到），暂时解决办法设置npmRebuild（这个有一定的风险），可以缓解rebuild二进制文件时候打包重编译报错问题。mac下browserview 属性 modal 设置为true时，不能设置x，y坐标。mac下主窗体和其子窗体不能同时选中，这个看业务情况了（我们表示很受影响）mac下chrome浏览器 滚动条不占宽度mac，win下对二进制的依赖包处理结果是不同的，（这个不算bug），但是可能导致路径问题。惊天大Bug，electron应用打开后，电脑息屏幕，睡眠，再唤醒后。有些功能不能正常使用，有些则不受影响，还没查出原因。可能原因很多，（mac内存回收，electron内存回收，chrome内核回收，引用的模块）都可能引起这个有些难度2020/05/01 - 2020/04/30最近的问题都比较棘手，第一个是自己编译的.node文件在电脑休眠后（且大于一定时间后。至少半小时），再引用会发生异常，应该是被系统回收了。目前的解决办法（用node全局 global 可以解决）electron签名，网上文章很多，其实步骤也不复杂，一步步操作下去就可以吧注册一个 Apple Developer Program(需要缴纳年费)下载并安装 Xcode生成，下载，然后安装签名证书（signing certificates）[electron-osx-sign], 直接签名[electron-packager] 打包 electron-osx-sign. 如果你正在使用 electron-packager，那么在签署包文件时请传—osx-sign=true参数(我用的是这个，以上两个没亲测) electron-builder 内置代码签名功能。 可参考electron.build/code-signing，主要是要配置env环境。注意点：包名和 p12名称一致。nrmnrm 锁定必要的包的版本，防止被动升级到最新版本。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://liubailing.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"bug","slug":"bug","permalink":"https://liubailing.github.io/tags/bug/"}],"keywords":[]},{"title":"前端之路","slug":"前端之路","date":"2019-12-04T16:00:00.000Z","updated":"2020-03-10T15:19:47.964Z","comments":true,"path":"20191205/前端之路/","link":"","permalink":"https://liubailing.github.io/20191205/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF/","excerpt":"","text":"一路走来，我应该是个前端了吧！初出茅庐很多年前，刚毕业那会，做的是.net工作，而且还是开发一款财务记账桌面应用，业务很复杂。天天忙于业务开发，而且是桌面软件，那时候布局主要是控制边距，组件基本是微软提供好的。基本是沉迷于大微软的winForm无法自拔。也就是没有前端的概念 —_—!初识前端后来因为各种原因，换了份工作，项目其实不错，当时项目是想做一个web页游的辅助工具，在web页面下方生成一个游戏辅助工具，这个项目就现在来说也是一个很有挑战的项目，1、 在一个工具条上要能发送消息，而且还要求消息能发送到游戏里面，当时只接通了几款游戏，2、 管理游戏，玩过的，推荐的，即将开服的等3、 管理游戏好友,还有信息这个所谓的游戏辅助工具当时最大的挑战是兼容性，不错IE6，火狐，当时好像还没chrome什么事。FF是调试神器可以，但是我当时也是一个存当耐特工程师，还是做aspx页面，主要提供数据给一个同事，大部分页面效果还都是他完成的，不过基本每天在一起调试，看着他改属性值，调样式，写hack。当时也没学到多少前端知识，两个二傻互夸，我说他样式写的NB，他说我.net写的很溜。哈哈… ，是不是觉得气氛不错这一年多确实有了一些前端的概念，jquery，ajax，dom操作开始接触些。后来一天老大说项目组黄了，我们将会调到其他项目组去。不过我还是去找了新公司迷失前端，收货项目经验接下来我来到了智购网，Boss是我老乡，井冈山人，技术牛X和管理Nice，所以后来基本都是和他在折腾项目，各种项目，接触智购网后，才有了大型项目的概念，整个项目对当时我来说真是开了眼界，后台项目，公司主站，投放平台，数据采集项目，商家、用户管理后台。底层工具，数据处理层，中间业务层，中间件层，各项目前台项目，基本每天都穿插在几个项目中折腾，那时候应该是写的一手好.net(chui xu~)，不过大概三个月后，由于当时大环境影响，互联网团购兴起，当时聚齐网和我们Boss关系的原因，我们团队全部加入聚齐网，jquery大法好瞬间有点大公司的感觉，在中关村快200人的开发团队，加入后，基本除了聚齐网主站，项目都.net重构开发，而我那时候也主导开发了好几个项目，后来主站当时有些模块都是直接用.net项目直接替换了。期间一年多，做了好几个项目，基本都是主程了，开始试着带几个新人， 这个时候基本从数据库一直撸到页面，可能是对当时用的框架熟悉了，后天驾轻就熟，基本没什么问题，比多棘手是页面效果，因为是团购网站，这个时候开始有了优化的概念，基本的js后置，雪碧图，cdn加速，Gzip压缩,cookie瘦身… 都尽量用上了，可以说jquery，及一些常用的插件用的比较溜了，知道用冒泡，写一些倒计时，和一些当时看起来比较炫的效果（偷笑）。后来随着团购公司的团灭公司在一夜醒来就说解散了前端挺好玩的来到了亿阳信通，是以.net高级工程师进来的，所在的部门主要是做一些电信增值业务的项目，有很多报表项目，当时对数据展示要丰富化，报表，图形，表格做的比较多。入职2个月后派了个封装插件的任务给我，这个基本是纯前端项目了，对smartTable，echart做二次封装，当时具体需求不太记得了，最后要去达到的目标是后台生成的数据能直接绑定到表格，表格、图标上的操作也能正确传到后台，后台根据操作重新生成数据，比如从排序，下钻，维度重新分析，重新筛选。当时还有个比较难的需求，就是封装后表格插件和图表插件还要互相通信，算是一个比较复杂的前端项目，当时没有vue、react这些框架。代码也用上了一些闭包，立即执行函数，观察者模式也用上了，只不过当时对这些概念还比较模糊，写了也不怎么清楚。完成了这两个需求后，又开始对条件进行封装，把常用的条件封装成一个组件，通过参数配置控制，实现页面筛选条件的自动化生成，最后简化的大部分报表页面的开发工作，自己也get到一些前端知识，对组件封装，js语法，dom操作都有比较多的实践，完成这些工作后也逐渐喜欢前端工作，之后就参与了多个出差驻场，那三个封装的组件在现场开发提升效率，给客户带来了价值，后来得到一个机会，接到了华为的面试。前端去哪儿了经过6轮的面试，很荣幸加入了华为,不过进去后有点小失落的就是，在华为不管之前的技术栈（我遇到而已），全新技术栈项目，在华为的5个月期间，对接了多个项目，当时印象比较深的是天天做操作服务器，部署新的项目对接数据。完整的文档，严格的项目评审流程让我这个linux门外汉也能较好的完成工作，还获得小组”季度之星“，这个对新人来说还不好拿的，期间心里一直惦记前端，再因为要出差国外，又一个机缘巧合的原因，宝驾租车需要一个前端组长，之后就去了宝驾租车邀请重返前端，自嗨来到宝驾租车（井冈山老板是合伙人），正式接起前端组长的职位。基本从组建队伍，到项目交付都是自己完成，期间回头完善了自己的前端知识，慢慢的把知识体系完善起来（当然现在也没做的很好），每天忙碌充实着，记忆最深是前端框架的搭建，前端MVVM已经盛行(当时是ng的天下)，最后我搭建了一套seajs+avalonjs 搭建的前端框架，当时amd，cmd的概念也出来了，前端模块化这些影响前端开发的概念忽然一起出来了，前端热闹起来了，框架在公司的多个项目中是使用的效果还不错，没有拖后腿，基本都是我们把前端页面逻辑都做完了，假数据模拟完成了，等待后端数据对接和验证。期间也没出现过什么大的失误。我觉得几年有每天醒来都感觉到进步了，不仅仅是前端技术，公司也做的不错。但是随着”共享车“这个在中国行情的伪命题下。公司从领头还是逐步走到了裁员的地步，和组员谈离职的煎熬真不好受，最后自己也出来了丢了的前端和井冈山老板一起出来后，折腾了多个项目，这期间就几个人基本也是从头撸到尾，.netcore、前端都做。这期间比较迷茫，中间的前端日新月异，由于都是Demo项目多一点，用的都不深。前端知识感觉落下了不少，折腾了两年多后，还是扛不住散了伙，这次也打算正式离开工作多年的北京找回来了，一起前进离开北京后，加入深圳八爪鱼，虽然是以全栈职位加入的公司，但是最后我还是选择了专职前端 。等于全新的开始，不管生活环境，还是工作环境，工作技术栈都是全新的开始，react electron、打包、安全加密…，都得深入踩坑。经过6个月的努力，window是第一版交付是使用。现在主要负责在一个月时间把mac版本搞出来…纵情向前前端的路上。 我 纵情向前！！！心里根本不信撸码只能到35岁这个砍，就算有这个砍，也要成为那个能越过这个砍的前端","categories":[{"name":"前端","slug":"前端","permalink":"https://liubailing.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://liubailing.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://liubailing.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端名词解释","slug":"名词解释","date":"2019-12-04T16:00:00.000Z","updated":"2020-03-10T18:03:40.572Z","comments":true,"path":"20191205/名词解释/","link":"","permalink":"https://liubailing.github.io/20191205/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/","excerpt":"","text":"前端术语的个人理解，按个人意思理解过来的，仅限参考，欢迎拍砖！组件化 ！== 模块化模块化只是在文件层面上，对代码和资源的拆分更注重在代码功能上 组件化是在设计层面，对UI（用户界面）的拆分。从UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件，注重的是在页功能上。前端工程化正所谓复杂的事情简单化，简单事情标准化，标准的事情工程化 使用软件工程这套早已存在的体系去对前端项目进行管理。软件工程化关注的是性能、稳定性、可用性、可维护性等方面，一切以这些为目标的工作都是&quot;前端工程化&quot;。至于模块化、组件化、XX 打包方案、制定自动化流程、制定开发规范，这些都是&quot;术&quot;。可能现在是这样，过两年又变了。并且每个项目自身特点不同，所有这些&quot;术&quot;都不应该成为衡量一个项目是否做了&quot;前端工程化&quot;的标准。","categories":[{"name":"前端","slug":"前端","permalink":"https://liubailing.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://liubailing.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"面试","permalink":"https://liubailing.github.io/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://liubailing.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"Mac 下解压 Asar","slug":"Mac下查看Asar","date":"2019-05-01T05:08:43.000Z","updated":"2020-04-28T00:38:12.395Z","comments":true,"path":"20190501/Mac下查看Asar/","link":"","permalink":"https://liubailing.github.io/20190501/Mac%E4%B8%8B%E6%9F%A5%E7%9C%8BAsar/","excerpt":"","text":"赠送 brew 升级直接升级123456# check brewbrew -v# update brewbrew update #等待即可github 源码升级12345678# 如果不行，那就切换更新源cd \" brew --repo)\"# check git remote status git remote -v# 换成其他的源，至于使用哪个网址建议看情况网上查git remote set-url origin https://git.coding.net/homebrew/homebrew.git#等待即可安装Asar模块123456789##check npmnpm -V#install asarnpm install -g asar#解压缩asar文件#asar extract 压缩文件 解压目录asar extract ./app.asar ./app#asar pack 压缩文件夹 压缩路径含文件名","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://liubailing.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Electron","slug":"Electron","permalink":"https://liubailing.github.io/tags/Electron/"}],"keywords":[]},{"title":"JS的面向对象和中的Class","slug":"JS/es6和ts中的Class","date":"2018-11-05T08:28:14.000Z","updated":"2020-04-27T00:18:55.502Z","comments":true,"path":"20181105/JS/es6和ts中的Class/","link":"","permalink":"https://liubailing.github.io/20181105/JS/es6%E5%92%8Cts%E4%B8%AD%E7%9A%84Class/","excerpt":"","text":"什么是面向对象维基百科的面向对象重点归纳面向对象思想中, 有两个主要的概念:类: 有相同的特征和行为的事物的抽象对象: 类的一个实例举个栗子：书籍是一个类，语文书是一个对象三大特点：封装：简单来说就是隐藏该隐藏的，暴露想暴露的继承：子类继承父类的属性和方法多态：同一个行为具有多个不同表现形式或形态的能力什么是class在oop编程语言中，class是oop实现信息封装的基础，类是一种用户定义引用数据类型，也称类类型。类的实例称为对象。es5仿照Class综上所述，js不是一个严格的面向对象语言，在es5时代可以说不是（个人理解），至少没有严格意义上的class，但是我们通过js原型可以实现，到这就有了构造函数这个名词，其实es5构造函数看上去就是一个普通的函数，","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://liubailing.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"keywords":[]},{"title":"好文分享","slug":"好文分享","date":"2018-11-05T05:08:43.000Z","updated":"2020-03-08T17:24:30.755Z","comments":true,"path":"20181105/好文分享/","link":"","permalink":"https://liubailing.github.io/20181105/%E5%A5%BD%E6%96%87%E5%88%86%E4%BA%AB/","excerpt":"","text":"Css高度坍塌绝对居中JS基础从event loop规范探究javaScript异步及浏览器更新渲染时机 视频解说","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://liubailing.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"keywords":[]},{"title":"JS的面向对象和中的Class","slug":"JS/es5和es6中的Class","date":"2018-11-03T11:28:22.000Z","updated":"2020-04-27T00:20:12.680Z","comments":true,"path":"20181103/JS/es5和es6中的Class/","link":"","permalink":"https://liubailing.github.io/20181103/JS/es5%E5%92%8Ces6%E4%B8%AD%E7%9A%84Class/","excerpt":"","text":"什么是面向对象维基百科的面向对象重点归纳面向对象思想中, 有两个主要的概念:类: 有相同的特征和行为的事物的抽象对象: 类的一个实例举个栗子：书籍是一个类，语文书是一个对象三大特点：封装：简单来说就是隐藏该隐藏的，暴露想暴露的继承：子类继承父类的属性和方法多态：同一个行为具有多个不同表现形式或形态的能力什么是class在oop编程语言中，class是oop实现信息封装的基础，类是一种用户定义引用数据类型，也称类类型。类的实例称为对象。es5仿照Class综上所述，js不是一个严格的面向对象语言，在es5时代可以说不是（个人理解），至少没有严格意义上的class，但是我们通过js原型可以实现，到这就有了构造函数这个名词，其实es5构造函数看上去就是一个普通的函数，","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://liubailing.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"keywords":[]},{"title":"构造函数和普通函数","slug":"JS/es5和es6的构造函数","date":"2018-10-25T05:08:18.000Z","updated":"2020-04-27T00:20:08.450Z","comments":true,"path":"20181025/JS/es5和es6的构造函数/","link":"","permalink":"https://liubailing.github.io/20181025/JS/es5%E5%92%8Ces6%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/","excerpt":"","text":"#","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://liubailing.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"keywords":[]},{"title":"原型和原型链","slug":"JS/原型和原型链","date":"2018-10-22T08:08:42.000Z","updated":"2020-04-27T00:18:31.873Z","comments":true,"path":"20181022/JS/原型和原型链/","link":"","permalink":"https://liubailing.github.io/20181022/JS/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"#","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://liubailing.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"keywords":[]},{"title":"构造函数和普通函数","slug":"JS/构造函数和普通函数","date":"2018-09-15T01:18:23.000Z","updated":"2020-04-27T00:20:23.811Z","comments":true,"path":"20180915/JS/构造函数和普通函数/","link":"","permalink":"https://liubailing.github.io/20180915/JS/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0/","excerpt":"","text":"#1、构造函数也是一个普通函数，创建方式和普通函数一样，但构造函数习惯上是首字母大写2、构造函数和普通函数的区别在于，调用的方式不一样，作用也不一样（构造函数是用来创建新实例对象）","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://liubailing.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"keywords":[]},{"title":"构造函数和普通函数","slug":"JS/构造函数和原型","date":"2018-09-12T03:26:34.000Z","updated":"2020-04-27T00:19:53.080Z","comments":true,"path":"20180912/JS/构造函数和原型/","link":"","permalink":"https://liubailing.github.io/20180912/JS/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B/","excerpt":"","text":"#","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://liubailing.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"keywords":[]},{"title":"函数","slug":"JS/函数","date":"2018-07-25T03:09:54.000Z","updated":"2020-04-29T00:35:38.578Z","comments":true,"path":"20180725/JS/函数/","link":"","permalink":"https://liubailing.github.io/20180725/JS/%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数定义函数是可以被调用的函数体代码，像程序本身一样，一个函数由称为函数体的一系列语句组成可以被传入值，（值传递，传入实参），注意：传入参数为引用类型时，会发生连锁改变有返回值的特性，不声明return情况下，默认返回undefined函数内部的this指向调用该函数的content，（也可以这样说，该函数是被谁调用，this就是条用该函数的content）也是一个对象，Function对象。可以和对象一样有自己的属性和方法函数作为一等公民，函数表达式","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://liubailing.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"keywords":[]},{"title":"CSS面试题","slug":"面试/CSS","date":"2017-05-11T16:00:00.000Z","updated":"2020-03-10T17:59:38.042Z","comments":true,"path":"20170512/面试/CSS/","link":"","permalink":"https://liubailing.github.io/20170512/%E9%9D%A2%E8%AF%95/CSS/","excerpt":"","text":"","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://liubailing.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"面试","permalink":"https://liubailing.github.io/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[]},{"title":"绝对居中问题","slug":"Html/绝对居中","date":"2017-04-20T16:00:00.000Z","updated":"2020-03-10T17:56:37.861Z","comments":true,"path":"20170421/Html/绝对居中/","link":"","permalink":"https://liubailing.github.io/20170421/Html/%E7%BB%9D%E5%AF%B9%E5%B1%85%E4%B8%AD/","excerpt":"","text":"绝对居中问题1. 负外边距 在线示例基本思路：将设置了绝对定位的子元素水平和垂直偏移50%，然后在水平和垂直方向分别偏移负自身宽高的一半，示意图如下：12345678910111213141516171819202122232425262728293031&lt;!-- html --&gt;&lt;div id=\"parent\"&gt; &lt;div id=\"son\"&gt; &lt;div id=\"cont\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- css --&gt;&lt;style&gt;#parent&#123; width: 500px; height: 300px; position: relative; background-color: rgb(46,95,62);&#125;#son&#123; width: 250px; height: 150px; position: absolute; left: 50%; top: 50%;&#125;#cont&#123; width: 100%; height: 150px; margin-left: -50%; margin-top: -75px; background-color: rgb(23,48,31);&#125;&lt;/style&gt;优点：兼容性好，代码量少不足：子元素的宽高需要确定，对于高度自适应的容器会带来问题，建议把盒子设置成box-sizing:border-box2. 负位移 在线示例基本思路：将设置了绝对定位的子元素水平和垂直偏移50%，然后用transforms属性值将子元素偏移负自身宽高的一半1234567891011121314151617181920212223&lt;!-- html --&gt;&lt;div id=\"parent\"&gt; &lt;div id=\"son\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- css --&gt;&lt;style&gt; #parent&#123; width: 500px; height: 300px; position: relative; background-color: rgb(46,95,62); &#125; #son&#123; width: 250px; height: 150px; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); background-color: rgb(23,48,31); &#125;&lt;/style&gt;优点：支持子容器高度自适应；适用于响应式布局环境；移动浏览器支持较好；代码量少不足：不支持IE8及以西啊浏览器；需要添加浏览器私有前缀；translate可能受transform其他子属性值的影响3. 表格块 在线示例基本思路：通过display中的table和table-cell属性，模拟表格布局123456789101112131415161718192021222324252627&lt;!-- html --&gt;&lt;div id=\"parent\"&gt; &lt;div id=\"son\"&gt; &lt;div id=\"cont\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- css --&gt;&lt;style&gt; #parent&#123; width: 500px; height: 300px; display: table; background-color: rgb(46,95,62); &#125; #son&#123; display: table-cell; vertical-align: middle; &#125; #cont&#123; width: 50%; height: 50%; margin: auto; background-color: rgb(23,48,31); &#125;&lt;/style&gt;优点：支持高度自适应；可适应响应式环境；适用于多个子元素水平垂直居中环境；兼容性好；不足：需要额外标签4. 行内块 在线示例基本思路：将子容器和任一伪元素设置为行内块及水平居中，然后对父容器文本居中，示意图如下：123456789101112131415161718192021222324252627282930&lt;!-- html --&gt;&lt;div id=\"parent\"&gt; &lt;div id=\"son\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- css --&gt;&lt;style&gt;#parent&#123; width: 500px; height: 250px; text-align: center; overflow: auto; background-color: rgb(46,95,62);&#125;#parent:after&#123; content: ''; display: inline-block; vertical-align: middle; height: 100%; width: 0;&#125;#son&#123; width: 250px; height: 150px; display: inline-block; vertical-align: middle; background-color: rgb(23,48,31);&#125;&lt;/style&gt;优点：支持子元素高度自适应；适应于多个子元素水平垂直居中环境；兼容性良好，IE7及以上支持不足：当存在多个子容器时，注意盒子之间的间隙5. 伸缩盒模型 在线示例基本思路：使用flexbox弹性盒模型设置居中1234567891011121314151617181920&lt;div id=\"parent\"&gt; &lt;div id=\"son\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; #parent&#123; width: 500px; height: 300px; background-color: rgb(46,95,62); display: flex; align-items: center; justify-content: center; &#125; #son&#123; width: 250px; height: 150px; background-color: rgb(23,48,31); &#125;&lt;/style&gt;优点：不需要设置子元素的宽高；适用于任意子元素水平垂直居中环境；不足：IE10及以上兼容，高级浏览器也部分存在兼容问题；需要添加浏览器私有前缀；可能存在性能问题。6. 绝对居中块 在线示例基本思路：设置子元素外边距auto及四个方向的偏移值为0做到水平垂直居中12345678910111213141516171819202122232425&lt;!-- html --&gt;&lt;div id=\"parent\"&gt; &lt;div id=\"son\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- css --&gt;&lt;style&gt; #parent&#123; width: 500px; height: 300px; background-color: rgb(46,95,62); position: absolute; &#125; #son&#123; width: 40%; height: 40%; background-color: rgb(23,48,31); margin: auto; position: absolute; top: 0; right: 0; left: 0; bottom: 0; &#125;&lt;/style&gt;优点：支持IE8及以上；代码量少，便签结构简单；通过用%设置宽高值实现适用于响应式环境的目的不足：高度必须定义","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://liubailing.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"keywords":[]},{"title":"高度坍塌","slug":"Html/高度坍塌","date":"2017-04-17T16:00:00.000Z","updated":"2020-03-10T17:46:36.509Z","comments":true,"path":"20170418/Html/高度坍塌/","link":"","permalink":"https://liubailing.github.io/20170418/Html/%E9%AB%98%E5%BA%A6%E5%9D%8D%E5%A1%8C/","excerpt":"","text":"参考Css参考样式&lt;style&gt; .clearfix {zoom: 1;} .clearfix:after { content: &quot;.&quot;; display: block; height: 0; visibility: hidden; clear: both } .content { display: block; padding: 5px 50px; } .box { float: left; display: block; padding: 5px 20px; margin-right: 5px; border: 1px #ddd solid; max-width: 300px; } .block {} h1 { text-align: center; } h3 { font-size: 14px; } .block { background: #cccccc; } .aside { width: 100px; height: 100px; background: orange; } .main { background: yellow; } &lt;/style&gt; &lt;style&gt; .pos { position: relative; background: red; overflow: hidden; } .pos1 { position: absolute; padding: 2px; } &lt;/style&gt; &lt;style type=&quot;text/css&quot;&gt; .floatBox .block { margin-top: 30px; } .floatBox .aside { float: left; } &lt;/style&gt; &lt;style type=&quot;text/css&quot;&gt; .posBox .block { position: relative; } .posBox .aside { position: absolute; top: 0; left: 0; } .posBox .main { margin-left: 100px; } &lt;/style&gt; &lt;style type=&quot;text/css&quot;&gt; .flexBox .block { display: flex; } .flexBox .aside {} .flexBox .main {} &lt;/style&gt;flex坍塌解决办法 示例不好解决 避免这样写。12345678910&lt;div class=\"box flexBox\"&gt; &lt;h1&gt;flex:布局 &lt;/h1&gt; &lt;hr&gt; &lt;h3&gt;1.子元素总宽度 大于 父级宽度的时候，（会自适应，这个就有点蛋疼了） &lt;/h3&gt; &lt;div class=\"block \"&gt; &lt;div class=\"aside\" style=\"opacity:.6;\"&gt;aside11&lt;/div&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;div class=\"\" style=\"width: 100%; background: #000;\"&gt;三&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;position 坍塌解决办法 示例父级元素设高度，父级：overflow: hidden, 给第二个div设置margin-top且值设为大于等于固定定位模块的高度给第二个div设置margin-top且值设为大于等于固定定位模块的高度,height: 1px; visibility: hidden;给父级元素设置line-height:且值设为大于等于固定定位模块的高度1234567891011121314151617181920212223242526272829&lt;!-- --&gt;&lt;div class=\"box posBox\"&gt; &lt;h1&gt;position:高度坍塌 &lt;/h1&gt; &lt;hr&gt; &lt;h3&gt;1.父级元素设高度，（废话） &lt;/h3&gt; &lt;div class=\"block \" style=\"height: 100px;\"&gt; &lt;div class=\"aside\"&gt;aside&lt;/div&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;/div&gt; &lt;!-- .使用after伪对象清除浮动--&gt; &lt;hr&gt; &lt;h3&gt;2.父级：overflow: hidden, 给第二个div设置margin-top且值设为大于等于固定定位模块的高度,(灰常鸡肋)&lt;/h3&gt; &lt;div class=\"block\" style=\"overflow: hidden\"&gt; &lt;div class=\"aside\"&gt;aside&lt;/div&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;div style=\"margin-top: 80px;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;h3&gt;3.给第二个div设置margin-top且值设为大于等于固定定位模块的高度,height: 1px; visibility: hidden;(灰常鸡肋)&lt;/h3&gt; &lt;div class=\"block\" style=\"overflow: hidden\"&gt; &lt;div class=\"aside\"&gt;aside&lt;/div&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;div style=\"margin-top: 80px;height: 1px; visibility: hidden;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;h3&gt;4.给父级元素设置line-height:且值设为大于等于固定定位模块的高度,（副作用大...）&lt;/h3&gt; &lt;div class=\"block\" style=\"line-height: 100px;\"&gt; &lt;div class=\"aside\"&gt;aside&lt;/div&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;float坍塌解决办法 示例在父元素结束前添加一个宽高为0，clear:both 的空div为父元素添加overflow: hidden使用after伪对象清除浮动1234567891011121314151617181920212223242526272829303132&lt;!-- --&gt;&lt;div class=\"box floatBox\"&gt; &lt;h1&gt;float:高度坍塌 &lt;/h1&gt; &lt;hr&gt; &lt;h3&gt;1.在父元素结束前添加一个宽高为0，clear:both 的空div &lt;/h3&gt; &lt;div class=\"block\"&gt; &lt;div class=\"aside\"&gt;aside&lt;/div&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;div class=\"clearfix\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- .使用after伪对象清除浮动--&gt; &lt;hr&gt; &lt;h3&gt;2.为父元素添加overflow: hidden&lt;/h3&gt; &lt;div class=\"block\" style=\"overflow: hidden\"&gt; &lt;div class=\"aside\"&gt;aside&lt;/div&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;/div&gt; &lt;!-- 添加伪元素 :after 解决float 坍塌问题--&gt; &lt;hr&gt; &lt;h3&gt;3.使用after伪对象清除浮动&lt;/h3&gt; &lt;div class=\"block clearfix\"&gt; &lt;div class=\"aside\"&gt;aside&lt;/div&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;/div&gt; &lt;!-- 添加伪元素 :after 解决float 坍塌问题--&gt; &lt;!-- &lt;hr&gt; &lt;h3&gt;5.使用after伪对象清除浮动&lt;/h3&gt; &lt;div class=\"block\" style=\"float: left; overflow: hidden;\"&gt; &lt;div class=\"aside\" style=\"display: inline-block;\"&gt;aside&lt;/div&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;/div&gt; --&gt;&lt;/div&gt;display 坍塌解决办法 示例行内元素height weight行内元素水平方向的margin-left; margin-right行内元素水平方向的padding-left; padding-right;可以生效1234567891011121314151617181920212223242526272829&lt;!-- --&gt;&lt;div class=\"box\"&gt; &lt;h1&gt;display:高度坍塌 &lt;/h1&gt; &lt;hr&gt; &lt;h3&gt;1.行内元素height weight 不能生效。 &lt;/h3&gt; &lt;div class=\"block\" style=\"overflow: hidden;\"&gt; &lt;span class=\"aside\" style=\"\"&gt;aside&lt;/span&gt; &lt;span class=\"main\" style=\"\"&gt;main&lt;/span&gt; &lt;/div&gt; &lt;hr&gt; &lt;h3&gt;2.行内元素水平方向的margin-left; margin-right;;可以生效。但是竖直方向的margin-bottom; margin-top; 却不能生效。 &lt;/h3&gt; &lt;div class=\"block\" style=\"overflow: hidden;\"&gt; &lt;span class=\"aside\" style=\"display: inline; margin: 10px;\"&gt;aside&lt;/span&gt; &lt;span class=\"main\" style=\"\"&gt;main&lt;/span&gt; &lt;/div&gt; &lt;hr&gt; &lt;h3&gt;3行内元素水平方向的padding-left; padding-right;可以生效。但是竖直方向的 padding-top; padding-bottom;却不能生效。 &lt;/h3&gt; &lt;div class=\"block\"&gt; &lt;span class=\"aside\" style=\"\"&gt;aside&lt;/span&gt; &lt;span class=\"main\" style=\"padding: 10px;\"&gt;main&lt;/span&gt; &lt;/div&gt; &lt;hr&gt; &lt;h5&gt;以上问题都可以 通过（ inline-block）不过这个好像有点过了~!~ &lt;/h5&gt; &lt;h6&gt;就好像说病人的腿有毛病想医治，结果医生直接把腿换了，虽然换腿也是医治，但... &lt;/h6&gt;&lt;/div&gt;","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://liubailing.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"keywords":[]},{"title":"Visual Studio Code 常用快捷键","slug":"Visual Studio Code 常用快捷键","date":"2016-06-08T00:57:52.000Z","updated":"2020-03-08T17:17:15.823Z","comments":true,"path":"20160608/Visual Studio Code 常用快捷键/","link":"","permalink":"https://liubailing.github.io/20160608/Visual%20Studio%20Code%20%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"主命令框F1 或 Ctrl+Shift+P: 打开命令面板。在打开的输入框内，可以输入任何命令，例如：按一下 Backspace 会进入到 Ctrl+P 模式在 Ctrl+P 下输入 &gt; 可以进入 Ctrl+Shift+P 模式在 Ctrl+P 窗口下还可以:文件名 跳转到对应文件? 列出当前可执行的动作! 显示 Errors或 Warnings，也可以 Ctrl+Shift+M: 跳转到行数，也可以 Ctrl+G 直接进入@ 跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入@ 根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入:进入# 根据名字查找 symbol，也可以 Ctrl+T常用快捷键编辑器与终端窗口管理同时打开多个终端窗口（查看多个项目)Ctrl+Shift+N 打开一个新窗口Ctrl+Shift+W 关闭窗口同时打开多个编辑器（查看多个文件）Ctrl+N 新建文件Ctrl+Tab 文件之间切换Ctrl+\\ 切出一个新的编辑器（最多 3 个） ，也可以按住 Ctrl + 鼠标点击 Explorer 里的文件名Ctrl+1、Ctrl+2、Ctrl+3左中右 3 个编辑器的快捷键Ctrl+ ` 3 个编辑器之间循环切换Ctrl+k然后按 ←/→ 编辑器换位置代码编辑格式调整Ctrl+[ 、 Ctrl+] 代码行缩进Ctrl+C/X 复制/剪切 当前行/当前选中内容Shift+Alt+F 代码格式化,或 Ctrl+Shift+P 后输入format codeAlt+↑/↓ 上/下移动一行Shift+Alt+↑/↓ 向上/向下复制一行Ctrl+Enter 在当前行下边插入一行Ctrl+Shift+Enter 在当前行上方插入一行光标相关Home 移动到行首End 移动到行尾Ctrl+End 移动到文件结尾Ctrl+Home 移动到文件开头F12 移动到定义处Alt+F12 定义处缩略图（只看一眼而不跳转过去）Ctrl+Shift+] 移动到后半个括号Shift+End 选择从光标到行尾Shift+Home 选择从行首到光标处Ctrl+Delete 删除光标右侧的所有字Shift+Alt+←/→ 扩展/缩小选取范围Ctrl+Alt+↑/↓，Alt+Shift+鼠标左键 多行编辑(列编辑)Ctrl+Shift+L 同时选中所有匹配Ctrl+D 下一个匹配的也被选中Ctrl+U 回退上一个光标操作重构代码Shift+F12 找到所有的引用Ctrl+F12 同时修改本文件中所有匹配的F2 重命名比如要修改一个方法名，可以选中后按 ，输入新的名字，回车，会发现所有的文件都修改了F8 跳转到下一个 Error 或 Warning，当有多个错误时可以按 逐个跳转查看 diff; 在 explorer 里选择文件右键-&gt; Set file to compare-&gt;需要对比的文件上右键选择-&gt;Compare with file_name_you_chose显示相关F11全屏Ctrl +/- zoomIn/zoomOutCtrl+B 侧边栏显/隐Ctrl+Shift+E 显示资源管理器Ctrl+Shift+F 显示搜索Ctrl+Shift+G 显示 GitCtrl+Shift+D 显示 DebugCtrl+Shift+U 显示 Output自动保存File -&gt; AutoSave ，或 Ctrl+Shift+P，输入 auto修改默认快捷键打开默认键盘快捷方式设置：File-&gt;Preferences-&gt;Keyboard Shortcuts，或Alt+F-&gt;p-&gt;k修改 keybindings.json：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Place your key bindings in this file to overwrite the defaults[ // ctrl+l 快速切换编辑器语言 &#123; \"key\": \"ctrl+l\", \"command\": \"workbench.action.editor.changeEncoding\", \"when\": \"editorFocus\" &#125;, // ctrl+] 在explorer.exe中打开当前编辑文件 &#123; \"key\": \"ctrl+]\", \"command\": \"workbench.action.files.revealActiveFileInWindows\", \"when\": \"editorFocus\" &#125;, // ctrl+shift+] 定位到VSCode资源管理器位置 &#123; \"key\": \"ctrl+shift+]\", \"command\": \"workbench.files.action.showActiveFileInExplorer\", \"when\": \"editorFocus\" &#125;, // ctrl+space 被切换输入法快捷键占用 &#123; \"key\": \"alt+space\", \"command\": \"editor.action.triggerSuggest\", \"when\": \"editorTextFocus\" &#125;, // ctrl+d 删除一行 &#123; \"key\": \"ctrl+d\", \"command\": \"editor.action.deleteLines\", \"when\": \"editorTextFocus\" &#125;, // 与删除一行的快捷键互换 &#123; \"key\": \"ctrl+shift+k\", \"command\": \"editor.action.addSelectionToNextFindMatch\", \"when\": \"editorFocus\" &#125;, // ctrl+shift+/多行注释 &#123; \"key\": \"ctrl+shift+/\", \"command\": \"editor.action.blockComment\", \"when\": \"editorTextFocus\" &#125;, // 定制与 sublime 相同的大小写转换快捷键，需安装 TextTransform 插件 &#123; \"key\": \"ctrl+k ctrl+u\", \"command\": \"uppercase\", \"when\": \"editorTextFocus\" &#125;, &#123; \"key\": \"ctrl+k ctrl+l\", \"command\": \"lowercase\", \"when\": \"editorTextFocus\" &#125;]前端开发必备插件PostCSS SortingstylelintstylefmtESLintjavascript standard formatbeautifyBabel ES6/ES7Debugger for ChromeAdd jsdoc commentsjavascript(ES6) code snippetsvueweexReactjs code snippetsReact Native ToolsNpm IntellisenseInstant MarkdownMarkdown ShortcutsTextTransform自定义设置参考VS Code 自定义配置参考：123456789101112131415161718192021&#123; \"editor.fontSize\": 18, \"files.associations\": &#123; \"*.es\": \"javascript\", \"*.es6\": \"javascript\" &#125;, // 控制编辑器是否应呈现空白字符 \"editor.renderWhitespace\": true, // 启用后，将在保存文件时剪裁尾随空格。 \"files.trimTrailingWhitespace\": true, // File extensions that can be beautified as javascript or JSON. \"beautify.JSfiles\": [ \"\", \"es\", \"es6\", \"js\", \"json\", \"jsbeautifyrc\", \"jshintrc\" ]&#125;相关参考官方快捷键大全","categories":[{"name":"工具","slug":"工具","permalink":"https://liubailing.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://liubailing.github.io/tags/%E5%B7%A5%E5%85%B7/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://liubailing.github.io/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-03-05T16:00:00.000Z","updated":"2020-03-08T02:03:01.023Z","comments":true,"path":"20160306/hello-world/","link":"","permalink":"https://liubailing.github.io/20160306/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","categories":[],"tags":[],"keywords":[]}]}